---
description: 
globs: 
alwaysApply: false
---
# Browserプロジェクト コーディング規約

## 概要
このドキュメントでは、Crystal、Nim、Zigのトリプルハイブリッド構成による自作ブラウザ開発のためのコーディング規約を定義します。高品質かつ一貫性のあるコードベースを維持するために、すべての開発者はこの規約に従ってください。

## 言語の使用範囲

### Crystal
- フロントエンド UI コンポーネント
- DOM 操作ロジック
- イベントハンドリングシステム
- ユーザー設定管理

### Nim
- ネットワーク通信層
- HTTP/HTTPS プロトコル実装
- キャッシュ管理
- セキュリティ機能

### Zig
- レンダリングエンジン
- JavaScript エンジン
- メモリ管理
- パフォーマンスクリティカルなコンポーネント

## 共通規約

### ファイル構成
- 1ファイルあたり最大500行まで
- 機能ごとに適切に分割すること
- 関連する機能は同じディレクトリに配置する

### コメント
- 全ての公開API/関数には必ずドキュメンテーションコメントを付ける
- 複雑なロジックには適切な説明コメントを追加する
- コード自体が自己説明的であるように努める
- コメントは日本語と英語の両方で記述可能

### 命名規則
- 変数名、関数名は常に意図を明確に表す名前を選ぶ
- 一時変数以外は単一文字の変数名を避ける
- 略語は広く知られているもの以外は使用しない

### エラー処理
- 全ての例外的状況を適切に処理する
- エラーメッセージは具体的かつ解決策を示唆するものにする
- パニックや未処理の例外を発生させない設計にする

### パフォーマンス
- メモリリークを防ぐために適切なリソース管理を行う
- 計算量の多い処理は非同期で実行する
- 重い処理はバックグラウンドスレッドで行う

## Crystal 固有の規約

### 命名規則
- クラス、モジュール: PascalCase (例: `UIComponent`)
- メソッド、変数: snake_case (例: `render_element`)
- 定数: SCREAMING_SNAKE_CASE (例: `MAX_CONNECTIONS`)

### コードスタイル
- インデントは2スペース
- 行の最大長は100文字
- メソッドチェーンは適切に改行する
- 条件分岐が複雑な場合は早期リターンパターンを使用する

### 型の使用
- 可能な限り型指定を行う
- ジェネリックを活用して型安全性を高める
- `nil`の可能性がある値は必ず`Nil`型とのユニオン型で表現する

### メソッド設計
- 1メソッドあたりの行数は30行以内を目指す
- 副作用を最小限に抑える
- イミュータブルなデータ構造を優先的に使用する

## Nim 固有の規約

### 命名規則
- プロシージャ、変数: camelCase (例: `fetchResource`)
- 型、オブジェクト: PascalCase (例: `HttpResponse`)
- 定数: PascalCase (例: `DefaultTimeout`)

### コードスタイル
- インデントは2スペース
- 行の最大長は80文字
- 複合文の場合はブロックを使用する
- プラグマは必要最小限に留める

### エラー処理
- 例外よりも`Option`型や結果型を優先する
- エラーは早期に検出して処理する
- 深いエラーネストを避ける

### 並行処理
- スレッド間の安全性に常に注意を払う
- 共有状態へのアクセスは適切に同期する
- ロックの保持時間を最小化する

## Zig 固有の規約

### 命名規則
- 関数: camelCase (例: `renderPage`)
- 構造体、列挙型: PascalCase (例: `RenderContext`)
- 定数: SCREAMING_SNAKE_CASE (例: `MAX_CACHE_SIZE`)
- ローカル変数: snake_case (例: `pixel_buffer`)

### メモリ管理
- アロケータを明示的に受け渡す設計とする
- 可能な限りコンパイル時に検出可能なエラー処理を行う
- メモリ解放の責任を明確にする

### エラー処理
- `try`/`catch`よりも`error union`を使用する
- エラーの種類は具体的に定義する
- エラー伝搬の経路を常に意識する

### パフォーマンス最適化
- ホットパスには`inline`を適切に使用する
- データレイアウトはキャッシュフレンドリーに設計する
- 条件分岐の予測可能性を考慮する

## インターフェース規約

### 言語間連携
- 各言語間の連携は明確に定義されたAPIを通じて行う
- データ形式はシンプルかつ効率的なものを選択する
- バイナリ互換性のある形式を優先する

### APIデザイン
- 一貫性のあるインターフェースを設計する
- バージョニングを適切に行い、後方互換性を維持する
- 拡張性を考慮した設計を行う

### テスト可能性
- 各コンポーネントは単体でテスト可能な設計にする
- モックやスタブを容易に挿入できるようにする
- 副作用を分離し、純粋な関数を多用する

## ドキュメント規約

### コードドキュメント
- 公開API/関数には必ず以下を含めること:
  - 簡潔な説明
  - パラメータの説明
  - 戻り値の説明
  - エラー条件
  - 使用例

### アーキテクチャドキュメント
- 各モジュールの役割と責任を明確に記述する
- モジュール間の依存関係を図示する
- 重要なデータの流れを説明する

### 変更履歴
- 重要な変更は必ずドキュメントに反映する
- 非互換な変更は特に明示的に記録する
- 変更の理由も記録しておく

## コミットメッセージ規約

### フォーマット
```
[コンポーネント名] タイトル (50文字以内)

詳細な説明 (72文字で改行)
- 変更点1
- 変更点2

関連チケット: #123
```

### タイプ
- feat: 新機能
- fix: バグ修正
- docs: ドキュメントのみの変更
- style: コードの意味に影響しない変更（空白、フォーマット等）
- refactor: バグ修正でも機能追加でもないコード変更
- perf: パフォーマンス向上のための変更
- test: テストの追加・修正
- chore: ビルドプロセスやツールの変更

## レビュー規約

### コードレビュー
- すべての変更は少なくとも1人のレビューを受ける
- レビュー時には以下を確認:
  - 機能要件の充足
  - コード品質
  - テストの充足度
  - パフォーマンスへの影響
  - セキュリティリスク

### 自己レビュー
- コミット前に自己レビューを行う
- 不要なデバッグコードが残っていないか確認
- TODOコメントが適切か確認

## パフォーマンス規約

### 最適化原則
- 「早すぎる最適化は諸悪の根源」を意識する
- プロファイリングによって最適化対象を特定する
- アルゴリズムの選択を最適化の第一歩とする

### ベンチマーク
- 重要なコンポーネントには必ずベンチマークを用意する
- 基準となるパフォーマンス指標を定義する
- 継続的にパフォーマンスをモニタリングする

## セキュリティ規約

### 入力検証
- すべてのユーザー入力を適切に検証する
- サニタイズしていない入力をそのまま使用しない
- XSS、CSRF、SQLインジェクションなどの攻撃を意識する

### 機密情報
- パスワードなどの機密情報は適切にハッシュ化して保存する
- 機密情報をログに出力しない
- ハードコードされた秘密鍵などを使用しない

### リソース制限
- 無限ループやリソース枯渇攻撃への対策を行う
- タイムアウト処理を適切に実装する
- リソース使用量に上限を設ける

## 持続可能な開発のために

### 技術的負債
- 技術的負債は計画的に返済する
- 回避策（ワークアラウンド）には必ずコメントとチケット番号を残す
- 実験的な実装は明示的にマークする

### リファクタリング
- 定期的にコードの健全性を評価する
- 重複コードを発見したら迅速に統合する
- 過度に複雑化したコードは分割・簡素化する

### 継続的改善
- この規約自体も定期的に見直し、改善する
- 新しいベストプラクティスを積極的に取り入れる
- チーム全体でコード品質に対する責任を共有する 